# REACT Reander_opmization

![Alt text](../images/canIReactBG/%EB%8B%B9%EC%8B%A0%EB%8F%84%ED%95%A0%EC%88%98%EC%9E%88%EB%8B%A4%EB%A6%AC%EC%95%A1%ED%8A%B8.png)

## 리액트에서 렌더링이란?

버츄얼돔에서 상태가 변경되었을때 리액트 트리가 변경되었을때,
Ui에 그려지는 과정

<br/>
<br/>

## 리액트는 이미 충분히 빠르다.

대부분의 서비스는 최적화를 깊이 고려하지 않아도 잘 동작한다.

 <br/>
<br/>

## 하지만

렌더링할 UI 요소와, 데이터가, 넓고, 깊어질 때 - 백오피스, 로그 데이터 시각화, ... 지도, ctc... 등등 무거운 작업을 하게된다면 최적화를 시켜야한다.

<br/>
<br/>

## 요약

미리 습관을 들이지 않으면, ... 돌이키기 힘든 상황이 올 수 있다.

렌더링 최적화가 필요해지는 시점에 잘못된 패턴으로 모든 패턴을 개발해놨다면 돌이킬 수 없을 수 있다.... ❌

### 서비스 성능 저하 방지

서비스 성장에 치명적이고 돌이킬 수 없는 성능 문제의 사전 예방

### 코드 퀄리티 확보

부적절한 설계 패턴 방지 및 팀 내 엔지니어 간 지식 공유 활성화

<br/>
<br/>

1. ## 참조 유지하기(하위 컴포넌트로 전달될 함수, ReaactNode, Children)

- 메모이제이션 - useMemo, useCallback
- 미적용시 하위 컴포넌트가 매번 새 콜백 함수의 참조를 받아 렌더링될 수 있음
- 하위 컴포넌트 전달 목적 외 사용 불필요

2. ## 상태 비교 전략(Redux - useSelector)

- Shallw equal / Strict equality (===) 전략
- 리턴이 오브젝트인 경우 얕은 비교 필수

```tsx
// ex
useSeletor((state) => ({ user: state.user }), shallowEqual);
```

3. ## Redux 를 대체하는 다른 상태 관리 라이브러리 도입

- Recoil, Jotai, Zustand, 전파받는 상태 줄이기
- 관리할 살태가 많고, 복잡한 비즈니스 로직 처리가 필요할 경우 도입 전 출분한 논의 필요!

4. ## PureComponent, React.memo

- Props 얕은 비교 적용하기
- 자주 업데이트 되는 컴포넌트에 적용 시 되려 성능 저하될 수 있음.
